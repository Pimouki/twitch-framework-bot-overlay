"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Colors = void 0;
var Colors;
(function (Colors) {
    /**
     *
     * @param red 0 - 255
     * @param green 0 - 255
     * @param blue 0 - 255
     * @param alpha 0 - 1
     * @return [0 - 1] values r g b alpha
     */
    function toVec4(red, green, blue, alpha) {
        return new Float32Array([red / 255, green / 255, blue / 255, alpha]);
    }
    Colors.toVec4 = toVec4;
    /**
     *
     * @param h hue 0 - 255
     * @param s saturation 0 -1
     * @param v value 0 -1
     */
    function hsvToRgb(h, s, v) {
        const c = v * s;
        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        const m = v - c;
        let rgb;
        if (h < 60) {
            rgb = [c, x, 0];
        }
        else if (h < 120) {
            rgb = [x, c, 0];
        }
        else if (h < 180) {
            rgb = [0, c, x];
        }
        else if (h < 240) {
            rgb = [0, x, c];
        }
        else if (h < 300) {
            rgb = [x, 0, c];
        }
        else {
            rgb = [c, 0, x];
        }
        const [r, g, b] = rgb;
        return [
            Math.round((r + m) * 255),
            Math.round((g + m) * 255),
            Math.round((b + m) * 255),
        ];
    }
    Colors.hsvToRgb = hsvToRgb;
    /**
     *
     * @param r red 0-255
     * @param g green 0-255
     * @param b red 0-255
     */
    function rgbToHsv(r, g, b) {
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const d = max - min;
        let h = 0;
        if (d === 0) {
            h = 0;
        }
        else if (max === r) {
            h = ((g - b) / d + 6) % 6;
        }
        else if (max === g) {
            h = (b - r) / d + 2;
        }
        else if (max === b) {
            h = (r - g) / d + 4;
        }
        h *= 60;
        const s = max === 0 ? 0 : d / max;
        const v = max / 255;
        return [h, s, v];
    }
    Colors.rgbToHsv = rgbToHsv;
    function rgbInvert(r, g, b) {
        return [r ^ 255, g ^ 255, b ^ 255];
    }
    Colors.rgbInvert = rgbInvert;
    /**
     *
     * @param r red 0-255
     * @param g green 0-255
     * @param b red 0-255
     * @param angle in radians
     */
    function rgbRotate(r, g, b, angle) {
        return rgbMatriceRotation(r, g, b, angleToMatriceArgument(angle));
    }
    Colors.rgbRotate = rgbRotate;
    function angleToMatriceArgument(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const sinSqrt = Math.sqrt(1 / 3) * sin;
        const cosTierce = (1 - cos) / 3;
        return [cos + cosTierce, cosTierce - sinSqrt, cosTierce + sinSqrt];
    }
    Colors.angleToMatriceArgument = angleToMatriceArgument;
    /**
     *
     * @param r red 0-255
     * @param g green 0-255
     * @param b red 0-255
     * @param A MatriceRotate
     * @param B MatriceRotate
     * @param C MatriceRotate
     */
    function rgbMatriceRotation(r, g, b, [A, B, C]) {
        return [
            A * r + B * g + C * b,
            C * r + A * g + B * b,
            B * r + C * g + A * b,
        ];
    }
    Colors.rgbMatriceRotation = rgbMatriceRotation;
})(Colors = exports.Colors || (exports.Colors = {}));
//# sourceMappingURL=colors.js.map