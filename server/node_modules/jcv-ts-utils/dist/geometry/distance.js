"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Distance = void 0;
var Distance;
(function (Distance) {
    Distance.inRange = (which, others, compareFunction) => {
        const calcDist = others.map((other, index) => ({ index, dist: pointToPoint(which, other) }));
        return calcDist
            .filter((tile) => compareFunction(tile.dist))
            .map((tile) => others[tile.index]);
    };
    function nearest(which, others) {
        return others.reduce((prev, current) => {
            const currentDistance = pointToPoint(which, current);
            if (currentDistance > prev.distance) {
                return prev;
            }
            return {
                distance: currentDistance,
                item: current,
            };
        }, { distance: Infinity, item: undefined });
    }
    Distance.nearest = nearest;
    function further(which, others) {
        return others.reduce((prev, current) => {
            const currentDistance = pointToPoint(which, current);
            if (currentDistance < prev.distance) {
                return prev;
            }
            return {
                distance: currentDistance,
                item: current,
            };
        }, { distance: 0, item: undefined });
    }
    Distance.further = further;
    function pointToCircle(point, { x, y, radius }) {
        return pointToPoint({ x, y }, point) - radius;
    }
    Distance.pointToCircle = pointToCircle;
    function circleToCircle({ x: x1, y: y1, radius: r1 }, { x: x2, y: y2, radius: r2 }) {
        return pointToPoint({ x: x1, y: y1 }, { x: x2, y: y2 }) - r1 - r2;
    }
    Distance.circleToCircle = circleToCircle;
    function pointToPoint({ x: p1x, y: p1y }, { x: p2x, y: p2y } = { x: 0, y: 0 }) {
        const dx = p1x - p2x;
        const dy = p1y - p2y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    Distance.pointToPoint = pointToPoint;
})(Distance = exports.Distance || (exports.Distance = {}));
//# sourceMappingURL=distance.js.map