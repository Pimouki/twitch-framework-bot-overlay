"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scene2d = void 0;
const commons_1 = require("../commons");
const camera2_1 = require("./camera2");
class Scene2d {
    container;
    canvas;
    ctx;
    fpsInterval;
    camera;
    height = 0;
    width = 0;
    pauseAnimation = false;
    elapsed = 0;
    forceUpdate = true;
    loopTime = 0;
    now = 0;
    then = 0;
    tickAnimation = 0;
    resizeObs;
    debounce;
    easingFunctions = [];
    updateListeners = [];
    constructor(container, { fps } = {}) {
        this.container = container;
        this.fpsInterval = 1000 / (fps || 60);
        this.then = window.performance.now();
        this.container.style.position = "relative";
        this.canvas = document.createElement("canvas");
        this.canvas.style.top = "0";
        this.canvas.style.left = "0";
        this.canvas.style.display = "block";
        this.canvas.style.position = "absolute";
        this.ctx = this.canvas.getContext("2d");
        this.ctx.imageSmoothingEnabled = false;
        container.appendChild(this.canvas);
        this.resizeObs = new ResizeObserver(this.debouncedResize.bind(this));
        this.debounce = (0, commons_1.createDebounce)(this.resize.bind(this), 300);
        this.resizeObs.observe(this.container);
        this.camera = new camera2_1.Camera2();
        this.resize();
        this.tickAnimation = requestAnimationFrame(this.animate.bind(this));
    }
    _items = [];
    get items() {
        return this._items;
    }
    set items(value) {
        this.cleanItems();
        value.forEach((item) => this.addItem(item));
    }
    addUpdateListener(callBack) {
        this.updateListeners = [...this.updateListeners, callBack];
    }
    removeUpdateListener(callBack) {
        this.updateListeners = this.updateListeners.filter((f) => f !== callBack);
    }
    addItem(item) {
        this.forceUpdate = true;
        this._items.push(item);
        this._items = this._items.sort((a, b) => a.scenePriority - b.scenePriority);
    }
    addMultipleItem(items) {
        items.forEach((i) => this.addItem(i));
    }
    animate(newTime) {
        this.tickAnimation = requestAnimationFrame(this.animate.bind(this));
        this.now = newTime;
        this.elapsed = this.now - this.then;
        if (this.elapsed > this.fpsInterval) {
            this.then = this.now - (this.elapsed % this.fpsInterval);
            if (!this.forceUpdate && !this._items.some((i) => i.isUpdated)) {
                return;
            }
            this.forceUpdate = false;
            this.loopTime++;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.save();
            // move camera
            this.camera.apply(this.ctx);
            this._items.forEach((d) => {
                this.ctx.save();
                // draw first
                d.draw2d(this, this.loopTime);
                this.ctx.restore();
                // set updated too false because draw
                if (!this.pauseAnimation) {
                    d.isUpdated = false;
                    d.update(this, this.loopTime);
                }
            });
            this.ctx.restore();
            this.updateListeners.forEach((ul) => ul(this, this.loopTime));
            this.applyEasing();
        }
    }
    cleanItems() {
        this._items = [];
    }
    async createTexture(url, repetition = null, matrix) {
        const image = await (0, commons_1.loadImage)(url);
        const pattern = this.ctx.createPattern(image, repetition);
        if (pattern && matrix) {
            pattern.setTransform(matrix);
        }
        return pattern;
    }
    destroy() {
        this.container.removeChild(this.canvas);
        this._items.forEach((i) => i.destroy());
        this.debounce.abort();
        this.resizeObs.disconnect();
        window.cancelAnimationFrame(this.tickAnimation);
    }
    async addEasing({ easing = commons_1.Easing.easeOutCubic, time = 20, start, scale, onNext, }) {
        return new Promise((resolve) => {
            this.forceUpdate = true;
            this.easingFunctions.push({
                easingCallback: (0, commons_1.createEasing)({
                    easing,
                    start,
                    scale,
                    time,
                }),
                onNext,
                onEnd: () => {
                    resolve();
                },
            });
        });
    }
    removeItem(item) {
        this._items = this._items.filter((f) => f !== item);
        this.forceUpdate = true;
    }
    resize() {
        const rect = this.container.getBoundingClientRect();
        this.width = rect.width;
        this.height = rect.height;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.forceUpdate = true;
        this._items.forEach((item) => {
            if (item.onResize) {
                item.onResize(this.width, this.height);
            }
        });
    }
    writeText(config) {
        this.ctx.save();
        let text = config.text;
        if (config.textAlign)
            this.ctx.textAlign = config.textAlign;
        if (config.direction)
            this.ctx.direction = config.direction;
        if (config.textBaseline)
            this.ctx.textBaseline = config.textBaseline;
        if (config.lineWidth)
            this.ctx.lineWidth = config.lineWidth;
        this.ctx.font = config.font
            ? `${config.font.size}px ${config.font.type}`
            : "26px sans-serif";
        if (config.maxWidth &&
            this.ctx.measureText(text).width > config.maxWidth * 2) {
            text = text.replace(" ", "\n");
        }
        const lines = text.split("\n");
        const measures = [];
        lines.forEach((l, i) => {
            measures.push(this.ctx.measureText(l));
            const lineHeight = config.lineHeight || config.font?.size || 26;
            const h = config.y + lineHeight * i;
            if (config.fillStyle) {
                this.ctx.fillStyle = config.fillStyle;
                this.ctx.fillText(l, config.x, h);
            }
            if (config.strokeStyle) {
                this.ctx.strokeStyle = config.strokeStyle;
                this.ctx.strokeText(l, config.x, h);
            }
        });
        this.ctx.restore();
        return measures;
    }
    applyEasing() {
        this.easingFunctions.forEach(({ easingCallback, onNext, onEnd }, index) => {
            easingCallback((n) => {
                this.forceUpdate = true;
                onNext(n);
            }, () => {
                this.easingFunctions = this.easingFunctions.filter((_, i) => i !== index);
                onEnd();
            });
        });
    }
    debouncedResize() {
        this.debounce.call();
    }
}
exports.Scene2d = Scene2d;
//# sourceMappingURL=scene2d.js.map