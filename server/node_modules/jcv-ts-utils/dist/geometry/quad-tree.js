"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadTree = void 0;
const intersection_1 = require("./intersection");
class QuadTree {
    boundary;
    capacity;
    objects = [];
    divided = false;
    /**      .----.----.
       //      | NW | NE |
       //      '----'----'
       //      | SW | SE |
       //      '----'----'
       */
    northwest;
    northeast;
    southwest;
    southeast;
    constructor(boundary, capacity = 4) {
        this.boundary = boundary;
        this.capacity = capacity;
    }
    subdivide() {
        const x = this.boundary.x, y = this.boundary.y, w = this.boundary.w / 2, h = this.boundary.h / 2;
        const ne = { x: x + w, y: y - h, w, h };
        this.northeast = new QuadTree(ne, this.capacity);
        const nw = { x: x - w, y: y - h, w, h };
        this.northwest = new QuadTree(nw, this.capacity);
        const se = { x: x + w, y: y + h, w, h };
        this.southeast = new QuadTree(se, this.capacity);
        const sw = { x: x - w, y: y + h, w, h };
        this.southwest = new QuadTree(sw, this.capacity);
        this.divided = true;
    }
    insert(obj) {
        if (!intersection_1.Intersection.pointInRectangle(obj, this.boundary)) {
            return;
        }
        if (this.objects.length < this.capacity) {
            this.objects.push(obj);
            return;
        }
        if (!this.divided) {
            this.subdivide();
        }
        this.northeast?.insert(obj);
        this.northwest?.insert(obj);
        this.southeast?.insert(obj);
        this.southwest?.insert(obj);
    }
    queryCircle(range) {
        const found = [];
        if (!intersection_1.Intersection.cercleInRectangle(range, this.boundary)) {
            return found;
        }
        else {
            this.objects.forEach((object) => {
                if (intersection_1.Intersection.pointInCircle(object, range)) {
                    found.push(object);
                }
            });
            this.northwest && found.push(...this.northwest.queryCircle(range));
            this.northeast && found.push(...this.northeast.queryCircle(range));
            this.southwest && found.push(...this.southwest.queryCircle(range));
            this.southeast && found.push(...this.southeast.queryCircle(range));
            return found;
        }
    }
    queryRect(range) {
        const found = [];
        if (!intersection_1.Intersection.rectInRect(this.boundary, range)) {
            return found;
        }
        else {
            this.objects.forEach((object) => {
                if (intersection_1.Intersection.pointInRectangle(object, range)) {
                    found.push(object);
                }
            });
            this.northwest && found.push(...this.northwest.queryRect(range));
            this.northeast && found.push(...this.northeast.queryRect(range));
            this.southwest && found.push(...this.southwest.queryRect(range));
            this.southeast && found.push(...this.southeast.queryRect(range));
            return found;
        }
    }
}
exports.QuadTree = QuadTree;
//# sourceMappingURL=quad-tree.js.map