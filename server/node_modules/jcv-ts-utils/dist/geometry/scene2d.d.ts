import { EasingFunction, RequireAtLeastOne } from "../commons";
import { Camera2 } from "./camera2";
type SceneCallBack = (scene: Scene2d, time: number) => void;
type addEasingProps = {
    start: number;
    scale: number;
    onNext: (value: number) => void;
    time?: number;
    easing?: EasingFunction;
};
interface Scene2DOptions {
    /**
     * image per seconde
     */
    fps?: number;
    /**
     * Time in ms
     */
    loopUpdateTime?: number;
}
export interface Item2Scene {
    isUpdated: boolean;
    onResize?: (canvasWidth: number, canvasHeight: number) => void;
    scenePriority: number;
    draw2d: SceneCallBack;
    update: SceneCallBack;
    destroy(): void;
}
type FillOrStroke = RequireAtLeastOne<{
    fillStyle: string | CanvasGradient | CanvasPattern;
    strokeStyle: string | CanvasGradient | CanvasPattern;
}>;
export type canvasWriteTextConfig = {
    textAlign?: CanvasTextAlign;
    textBaseline?: CanvasTextBaseline;
    direction?: CanvasDirection;
    text: string;
    maxWidth?: number;
    font?: {
        type: string;
        size: number;
    };
    x: number;
    y: number;
    lineWidth?: number;
    lineHeight?: number;
} & FillOrStroke;
export declare class Scene2d {
    private container;
    readonly canvas: HTMLCanvasElement;
    readonly ctx: CanvasRenderingContext2D;
    fpsInterval: number;
    camera: Camera2;
    height: number;
    width: number;
    pauseAnimation: boolean;
    private elapsed;
    private forceUpdate;
    private loopTime;
    private now;
    private then;
    private tickAnimation;
    private resizeObs;
    private debounce;
    private easingFunctions;
    private updateListeners;
    constructor(container: HTMLElement, { fps }?: Scene2DOptions);
    private _items;
    get items(): Item2Scene[];
    set items(value: Item2Scene[]);
    addUpdateListener(callBack: SceneCallBack): void;
    removeUpdateListener(callBack: SceneCallBack): void;
    addItem(item: Item2Scene): void;
    addMultipleItem(items: Item2Scene[]): void;
    animate(newTime: DOMHighResTimeStamp): void;
    cleanItems(): void;
    createTexture(url: string, repetition?: string | null, matrix?: DOMMatrix): Promise<CanvasPattern | null>;
    destroy(): void;
    addEasing({ easing, time, start, scale, onNext, }: addEasingProps): Promise<void>;
    removeItem(item: Item2Scene): void;
    resize(): void;
    writeText(config: canvasWriteTextConfig): TextMetrics[];
    private applyEasing;
    private debouncedResize;
}
export {};
