"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Point = void 0;
const commons_1 = require("../commons");
var Point;
(function (Point) {
    Point.equal = ({ x: p1x, y: p1y }, { x: p2x, y: p2y }) => {
        return p1x === p2x && p1y === p2y;
    };
    function lerp({ x: x1, y: y1 }, { x: x2, y: y2 }, t) {
        return { x: commons_1.NumberUtils.lerp(x1, x2, t), y: commons_1.NumberUtils.lerp(y1, y2, t) };
    }
    Point.lerp = lerp;
    function opposite({ x, y }) {
        return { x: -y, y: -x };
    }
    Point.opposite = opposite;
    function perp({ x, y }) {
        return { x: -y, y: x };
    }
    Point.perp = perp;
    function dotProduct({ x: p1x, y: p1y }, { x: p2x, y: p2y }) {
        return p1x * p2x + p1y * p2y;
    }
    Point.dotProduct = dotProduct;
    function angleTo({ x: p1x, y: p1y }, { x: p2x, y: p2y }) {
        return Math.atan2(p2y - p1y, p2x - p1x);
    }
    Point.angleTo = angleTo;
    function angleFrom({ x: p1x, y: p1y }, { x: p2x, y: p2y }) {
        return Math.atan2(p1y - p2y, p1x - p2x);
    }
    Point.angleFrom = angleFrom;
    function rotate({ x: originX, y: originY }, { x: rotateAnchorX, y: rotateAnchorY }, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const dx = originX - rotateAnchorX;
        const dy = originY - rotateAnchorY;
        return {
            x: dx * cos + dy * sin + rotateAnchorX,
            y: -dx * sin + dy * cos + rotateAnchorY,
        };
    }
    Point.rotate = rotate;
    function clamp({ x: x, y: y }, { x: xMin, y: yMin }, { x: xMax, y: yMax }) {
        return {
            x: commons_1.NumberUtils.clamp(xMin, x, xMax),
            y: commons_1.NumberUtils.clamp(yMin, y, yMax),
        };
    }
    Point.clamp = clamp;
    function boundaryLoop({ x: x, y: y }, { x: xMin, y: yMin }, { x: xMax, y: yMax }) {
        return {
            x: commons_1.NumberUtils.rangeLoop(xMin, x, xMax),
            y: commons_1.NumberUtils.rangeLoop(yMin, y, yMax),
        };
    }
    Point.boundaryLoop = boundaryLoop;
    function sum(points) {
        return points.reduce((prev, curr) => operation(prev, curr, (a, b) => a + b), { x: 0, y: 0 });
    }
    Point.sum = sum;
    function operation(a, b, method) {
        if (typeof b === "number") {
            return {
                x: method(a.x, b),
                y: method(a.y, b),
            };
        }
        return {
            x: method(a.x, b.x),
            y: method(a.y, b.y),
        };
    }
    Point.operation = operation;
    function average(points) {
        return operation(sum(points), points.length, (a, b) => a / b);
    }
    Point.average = average;
    function translateByVector(point, angle, length) {
        return operation(point, { x: Math.cos(angle) * length, y: Math.sin(angle) * length }, (a, b) => a + b);
    }
    Point.translateByVector = translateByVector;
    function coordinateRatioToScreen(x, y, width, height) {
        return {
            x: Math.round(width * x),
            y: Math.round(height * y),
        };
    }
    Point.coordinateRatioToScreen = coordinateRatioToScreen;
})(Point = exports.Point || (exports.Point = {}));
//# sourceMappingURL=point.js.map